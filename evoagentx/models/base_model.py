import yaml
from abc import ABC, abstractmethod
from pydantic import Field
from typing import Union, Optional, Type, Callable, List

from ..core.parser import Parser
from .model_configs import LLMConfig
from ..core.module_utils import (
    parse_json_from_text, 
    get_type_name,
    parse_xml_from_text,
    parse_data_from_text
)


PARSER_VALID_MODE = ["str", "json", "xml", "title", "custom"]

class LLMOutputParser(Parser):

    """
    a basic LLM output parser that directly store the text generated by LLM in the .text attribute.
    """
    content: str = Field(default=None, exclude=True, description="the text generated by LLM")

    @classmethod
    def get_attrs(cls, return_type: bool = False) -> List[Union[str, tuple]]:
        attrs = [] 
        exclude_attrs = ["class_name", "content"]
        for field, field_info in cls.model_fields.items():
            if field not in exclude_attrs:
                if return_type:
                    field_type = get_type_name(field_info.annotation)
                    attrs.append((field, field_type))
                else:
                    attrs.append(field)
        return attrs
    
    @classmethod
    def get_attr_descriptions(cls) -> dict:
        """
        return the attributes and its description
        """
        attrs = cls.get_attrs()
        results = {} 
        for field_name, field_info in cls.model_fields.items():
            if field_name not in attrs:
                continue
            field_desc = field_info.description if field_info.description is not None else "None"
            results[field_name] = field_desc
        return results

    @classmethod
    def get_content_data(cls, content: str, parse_mode: str = "json", parse_func: Optional[Callable] = None, **kwargs) -> dict:

        """
        parse the LLM generated content into a dict.

        Args:
            content (str): the content to parse.
            mode (str): the mode to parse the content, must be one of: ['str', 'json', 'xml', 'title', 'custom'].
            parse_func (Callable, optional): the function to parse the content, only valid when `mode` is 'custom'. 
        
        Returns:
            dict: the parsed content.
        """

        attrs = cls.get_attrs()
        if len(attrs) <= 0:
            return {} 
        
        if parse_mode == "str":
            parse_func = cls._parse_str_content
        elif parse_mode == "json":
            parse_func = cls._parse_json_content
        elif parse_mode == "xml":
            parse_func = cls._parse_xml_content
        elif parse_mode == "title":
            parse_func = cls._parse_title_content
        elif parse_mode == "custom":
            if parse_func is None:
                raise ValueError("`parse_func` must be provided when `parse_mode` is 'custom'.")
        else:
            raise ValueError(f"Invalid value '{parse_mode}' detected for `parse_mode`. Available choices: {PARSER_VALID_MODE}")
        data = parse_func(content=content, **kwargs)
        return data
    
    @classmethod
    def _parse_str_content(cls, content: str, **kwargs) -> dict:
        # if `parse_mode=str` in llm.generate(), it will set all the defined parameters to `content`
        attrs = cls.get_attrs()
        return {attr: content for attr in attrs}
    
    @classmethod 
    def _parse_json_content(cls, content: str, **kwargs) -> dict:

        extracted_json_list = parse_json_from_text(content)
        if len(extracted_json_list) > 0:
            json_str = extracted_json_list[0] # only use the first JSON
            try:
                data = yaml.safe_load(json_str)
            except Exception:
                raise ValueError(f"The generated content is not a valid JSON string:\n{json_str}")
        else:
            raise ValueError(f"The following generated content does not contain JSON string!\n{content}")
        
        return data
    
    @classmethod
    def _parse_xml_content(cls, content: str, **kwargs) -> dict:
        attrs_with_types: List[tuple] = cls.get_attrs(return_type=True)
        data = {} 
        for attr, attr_type in attrs_with_types:
            attr_raw_value_list = parse_xml_from_text(text=content, label=attr)
            if len(attr_raw_value_list) > 0:
                attr_raw_value = attr_raw_value_list[0]
                try:
                    attr_value = parse_data_from_text(text=attr_raw_value, datatype=attr_type)
                except Exception:
                    raise ValueError(f"Cannot parse text: {attr_raw_value} into {attr_type} data!")
            else:
                raise ValueError(f"The following generated content does not contain xml label <{attr}>xxx</{attr}>!\n{content}")
            data[attr] = attr_value
        return data
    
    @classmethod
    def _parse_title_content(cls, content: str, title_format: str = "## {title}", **kwargs) -> dict:
        """
        parse the content with title format. e.g.
        ## title1
        content1
        ## title2
        content2

        Args:
            content (str): the content to parse.
            title_format (optional, str): the format of the title, default is "## {title}".

        Returns:
            dict: the parsed content.
        """
        attrs: List[str] = cls.get_attrs()
        if not attrs:
            return {}
        
        output_titles = [title_format.format(title=attr) for attr in attrs]

        def is_output_title(text: str):
            return any(text.strip().startswith(title) for title in output_titles)

        data = {}
        current_output_name: str = None
        current_output_content: list = None
        for line in content.split("\n"):
            if is_output_title(line):
                if current_output_name is not None and current_output_content is not None:
                    data[current_output_name] = "\n".join(current_output_content)
                current_output_content = []
                current_output_name = line.replace("#", "").strip()
            else: 
                if current_output_content is not None:
                    current_output_content.append(line)
        if current_output_name is not None and current_output_content is not None:
            data[current_output_name] = "\n".join(current_output_content)
        return data
    
    @classmethod
    def parse(cls, content: str, parse_mode: str = "json", parse_func: Optional[Callable] = None, **kwargs):
        """
        the method used to parse text generated by LLM. This method only passes the input text to the .text attribute. 
        """
        if parse_mode not in PARSER_VALID_MODE:
            raise ValueError(f"'{parse_mode}' is an invalid value for `parse_mode`. Available choices: {PARSER_VALID_MODE}.")
        if not isinstance(content, str):
            raise ValueError(f"The input to {cls.__name__}.parse should be a str, but found {type(content)}.")
        data = cls.get_content_data(content=content, parse_mode=parse_mode, parse_func=parse_func, **kwargs)
        data.update({"content": content})
        parser = cls.from_dict(data, **kwargs)
        # parser.content = content
        return parser

    def __str__(self) -> str:
        return self.to_str()
    
    def to_str(self, **kwargs) -> str:
        return self.content
    
    def get_structured_data(self) -> dict:
        attrs = type(self).get_attrs()
        data = self.to_dict(ignore=["class_name"])
        # structured_data = {attr: data[attr] for attr in attrs}
        structured_data = {key: value for key, value in data.items() if key in attrs}
        return structured_data



class BaseLLM(ABC):
    
    def __init__(self, config: LLMConfig, **kwargs):

        self.config = config
        self.kwargs = kwargs
        self.init_model()
    
    @abstractmethod
    def init_model(self):
        pass

    def __deepcopy__(self, memo):
        # return the same instance when deepcopy
        memo[id(self)] = self
        return self

    @abstractmethod
    def formulate_messages(self, prompts: List[str], system_messages: Optional[List[str]] = None) -> List[List[dict]]:
        """
        Converts input prompts into the chat format compatible with different LLMs.

        Args:
            prompts (List[str]): A list of user prompts that need to be converted.
            system_messages (Optional[List[str]]): An optional list of system messages that provide instructions or context to the model.
        
        Returns:
            List[List[dict]]: A list of message lists, where each inner list contains messages in the chat format required by LLMs. 
        """
        pass

    @abstractmethod
    def single_generate(self, messages: List[dict], **kwargs) -> str:
        """
        generate LLM output for a given prompt. 

        Args:
            prompt (str): the input to the LLM.
            generation_config (LLMGenerationConfig): the generation config for LLM.
        
        Returns:
            str: the generated output from LLM.
        """
        pass

    @abstractmethod
    def batch_generate(self, batch_messages: List[List[dict]], **kwargs) -> List[str]:
        """
        generate outputs for a batch of prompts. 

        Args: 
            prompts (List[str]): a batch of inputs to the LLM. 
            generation_config (LLMGenerationConfig): the generation config for LLM.            
        
        Returns:
            List[str]: a list of generated outputs from LLM.
        """
        pass

    def parse_generated_text(self, text: str, parser: Optional[Type[LLMOutputParser]]=None, parse_mode: Optional[str] = "json", parse_func: Optional[Callable] = None, **kwargs) -> LLMOutputParser:
        """
        use parser to obtain a structured output. 

        Args: 
            text (str): a text that potentially contains structured string. 
            parser (Type[LLMOutputParser]): an LLMOutputParser class. 
        
        Returns:
            LLMOutputParser: an LLMOutputParser object. 
        
        Note: 
            use parser.parse(text) to obtain the result. 
        """
        if not parser:
            parser = LLMOutputParser
        return parser.parse(text, parse_mode=parse_mode, parse_func=parse_func)

    def parse_generated_texts(self, texts: List[str], parser: Optional[Type[LLMOutputParser]]=None, parse_mode: Optional[str] = "json", parse_func: Optional[Callable] = None, **kwargs) -> List[LLMOutputParser]:

        parsed_results = [self.parse_generated_text(text=text, parser=parser, parse_mode=parse_mode, parse_func=parse_func, **kwargs) for text in texts]
        return parsed_results

    def generate(
        self,
        prompt: Optional[Union[str, List[str]]] = None,
        system_message: Optional[Union[str, List[str]]] = None,
        messages: Optional[Union[List[dict],List[List[dict]]]] = None,
        parser: Optional[Type[LLMOutputParser]] = None,
        parse_mode: Optional[str] = "json", 
        parse_func: Optional[Callable] = None,
        **kwargs
    ) -> Union[LLMOutputParser, List[LLMOutputParser]]:
        
        """
        generate LLM output(s) for (a) prompt(s)/messages and parsed the result into an LLMOutputParser object. 

        Args:
            prompt (Union[str, List[str]]): the input to the LLM. 
            system_message (str): the system message for the LLM. 
            messages: (Union[List[dict],List[List[dict]]]): the chat message for the LLM. 
            parser (Optional[Type[LLMOutputParser]]): A LLMOutputParser (sub)class used to parse the LLM output.
                This class should implement .parse() method to parse the output. If None, LLMOutputParser will be used by default.
        
        Note:
            Either prompt or messages must be provided. Raise an error if both prompt and messages are provided or none of them is provided. 
            If parser is None, use LLMOutputParser by default. 
            Need to calculate the cost of an LLM call!
        """

        if not (prompt or messages):
            raise ValueError("Either 'prompt' or 'messages' must be provided.")
        if prompt and messages:
            raise ValueError("Both 'prompt' and 'messages' are provided. Please provide only one of them.")

        single_generate = False
        if messages is not None:
            if not messages: # empty messages
                return [] 
            if isinstance(messages[0], dict):
                single_generate = True
                messages = [messages]
        
        if prompt is not None:
            if isinstance(prompt, str):
                single_generate = True
                prompt = [prompt]
                if system_message:
                    if not isinstance(system_message, str):
                        raise TypeError(f"'system_message' should be a string when passing a single prompt, but found {type(system_message)}.")
                    system_message = [system_message]
                messages = self.formulate_messages(prompts=prompt, system_messages=system_message)
            elif isinstance(prompt, list) and all(isinstance(p, str) for p in prompt):
                single_generate = False
                if not prompt: # empty prompt
                    return []
                if system_message:
                    if not isinstance(system_message, list) or len(prompt) != len(system_message):
                        raise ValueError(f"'system_message' should be a list of string when passing multiple prompts and the number of prompts ({len(prompt)}) must match the number of system messages ({len(system_message)}).")
                messages = self.formulate_messages(prompts=prompt, system_messages=system_message)
            else:
                raise ValueError(f"'prompt' must be a str or List[str], but found {type(prompt)}.")
        
        generated_texts = self.batch_generate(batch_messages=messages, **kwargs)
        parsed_outputs = self.parse_generated_texts(texts=generated_texts, parser=parser, parse_mode=parse_mode, parse_func=parse_func, **kwargs)
        output = parsed_outputs[0] if single_generate else parsed_outputs

        return output


__all__ = ["LLMConfig", "BaseLLM", "LLMOutputParser"]


import json
from pydantic import create_model, Field
from typing import Union, Optional, Callable, Type, List

from .agent import Agent
from ..core.logging import logger
from ..core.module_utils import parse_json_from_llm_output
from ..models.base_model import BaseLLM, LLMOutputParser, PARSER_VALID_MODE
from ..prompts.utils import DEFAULT_SYSTEM_PROMPT
from ..actions.action import Action, ActionInput, ActionOutput
from ..utils.utils import generate_dynamic_class_name

OUTPUT_EXTRACTION_PROMPT = """
You are given the following text:
{text}

Within this text, there are specific outputs we want to extract. Please locate and extract the content for each of the following outputs:
{output_description}

**Instructions:**
1. Read through the provided text carefully.
2. For each of the listed output names, extract the corresponding content from the text. 
3. Return your findings in a single JSON object, where the JSON keys **exactly match** the output names given above.
4. If you cannot find content for an output, set its value to an empty string ("") or `null`.
5. Do not include any additional keys in the JSON. 
6. Your final output should be valid JSON and should not include any explanatory text.

**Example JSON format:**
{{
  "<OUTPUT_NAME_1>": "Extracted content here",
  "<OUTPUT_NAME_2>": "Extracted content here",
  "<OUTPUT_NAME_3>": "Extracted content here"
}}

Now, based on the text and the instructions above, provide your final JSON output.
"""


def customize_action_execute(self, llm: Optional[BaseLLM] = None, inputs: Optional[dict] = None, sys_msg: Optional[str]=None, return_prompt: bool = False, **kwargs) -> ActionOutput:

    prompt_params_names = self.inputs_format.get_attrs()
    # prompt_params_values = {param: inputs.get(param, "") for param in prompt_params_names}
    prompt_params_values = {}
    for param in prompt_params_names:
        value = inputs.get(param, "")
        if isinstance(value, str):
            prompt_params_values[param] = value
        elif isinstance(value, (dict, list)):
            prompt_params_values[param] = json.dumps(value, indent=4)
        else:
            raise TypeError(f"The input type {type(value)} to `customize_action_execute` is invalid! Valid types: [str, dict, list].")
    prompt = self.prompt.format(**prompt_params_values)
    # output = llm.generate(prompt=prompt, system_message=sys_msg, parser=self.outputs_format)
    llm_output: LLMOutputParser = llm.generate(prompt=prompt, system_message=sys_msg)
    try:
        output = self.outputs_format.parse(llm_output.content, parse_mode=self.parse_mode, parse_func=self.parse_func)
    except Exception:
        logger.warning(f"Couldn't automatically extract output data for '{self.name}'. Use LLM to extract output data ...")
        attr_descriptions: dict = self.outputs_format.get_attr_descriptions()
        output_description_list = [] 
        for i, (name, desc) in enumerate(attr_descriptions.items()):
            output_description_list.append(f"{i+1}. {name}\nDescription: {desc}")
        output_description = "\n\n".join(output_description_list)
        extraction_prompt = OUTPUT_EXTRACTION_PROMPT.format(text=llm_output.content, output_description=output_description)
        llm_extracted_output: LLMOutputParser = llm.generate(prompt=extraction_prompt)
        llm_extracted_data: dict = parse_json_from_llm_output(llm_extracted_output.content)
        output = self.outputs_format.from_dict(llm_extracted_data)

    if return_prompt:
        return output, prompt
    
    return output


class CustomizeAgent(Agent):

    """
    A class to initialize an Agent specified by the user or generated by an LLM. Input format:
    {
        "name": str, 
        "description": str, 
        "prompt": str, 
        "llm_config": dict, / "llm": BaseLLM, 
        "inputs": [
            {name: str, type: str, description: str, [required: bool]},
        ],
        "outputs": [
            {name: str, type: str, description: str, [required: bool]}
        ],
        "system_prompt" (optional): str, default is DEFAULT_SYSTEM_PROMPT
        "output_parser" (optional): Type[ActionOutput],
        "parse_mode" (optional): str, default is "title"
        "parse_func" (optional): Callable, default is None
    }
    """
    def __init__(self, **kwargs):
        """
        Initialize the customize agent.
        """
        name = kwargs["name"]
        description = kwargs["description"]
        prompt = kwargs.pop("prompt", None)
        inputs = kwargs.pop("inputs", [])
        outputs = kwargs.pop("outputs", [])
        system_prompt = kwargs.pop("system_prompt", None) or DEFAULT_SYSTEM_PROMPT 

        parse_mode = kwargs.pop("parse_mode", "title") # default is 'title'
        if parse_mode not in PARSER_VALID_MODE:
            raise ValueError(f"'{parse_mode}' is an invalid value for `parse_mode`. Available choices: {PARSER_VALID_MODE}.")
        
        parse_func = kwargs.pop("parse_func", None)
        if parse_func is not None:
            if not callable(parse_func):
                raise ValueError("`parse_func` must be a callable function.")
        if parse_mode == "custom":
            if parse_func is None:
                raise ValueError("`parse_func` must be provided when `parse_mode` is 'custom'.")
        
        output_parser = kwargs.pop("output_parser", None)
        customize_action = self.create_customize_action(
            name=name, 
            desc=description, 
            prompt=prompt, 
            inputs=inputs, 
            outputs=outputs, 
            parse_mode=parse_mode, 
            parse_func=parse_func,
            output_parser=output_parser
        )
        super().__init__(system_prompt=system_prompt, actions=[customize_action], **kwargs)
        self._store_inputs_outputs_info(inputs, outputs)

    @property
    def customize_action_name(self):
        for action in self.actions:
            if action.name != self.cext_action_name:
                return action.name
        raise ValueError("Couldn't find the customize action name!")
    
    def create_customize_action(
        self, 
        name: str, 
        desc: str, 
        prompt: str, 
        inputs: List[dict], 
        outputs: List[dict], 
        parse_mode: str, 
        parse_func: Optional[Callable] = None,
        output_parser: Optional[ActionOutput] = None
    ) -> Action:
        """
        Create the customize action.
        """
        assert prompt is not None, "must provide `prompt` when creating CustomizeAgent"

        # create the action input type
        action_input_fields = {}
        for field in inputs:
            required = field.get("required", True)
            if required:
                action_input_fields[field["name"]] = (str, Field(description=field["description"]))
            else:
                action_input_fields[field["name"]] = (Optional[str], Field(description=field["description"]))
        
        action_input_type = create_model(
            generate_dynamic_class_name(name+" ActionInput"),
            **action_input_fields, 
            __base__=ActionInput
        )

        # create the action output type
        if output_parser is None:
            action_output_fields = {}
            for field in outputs:
                required = field.get("required", True)
                if required:
                    action_output_fields[field["name"]] = (Union[str, dict, list], Field(description=field["description"]))
                else:
                    action_output_fields[field["name"]] = (Optional[Union[str, dict, list]], Field(description=field["description"]))
            
            action_output_type = create_model(
                generate_dynamic_class_name(name+" ActionOutput"),
                **action_output_fields, 
                __base__=ActionOutput,
                # get_content_data=customize_get_content_data,
                # to_str=customize_to_str
            )
        else:
            self._check_output_parser(outputs, output_parser)
            action_output_type = output_parser

        customize_action_cls = create_model(
            generate_dynamic_class_name(name+" Action"),
            parse_mode=(Optional[str], Field(default="title", description="the parse mode of the action, must be one of: ['title', 'str', 'json', 'xml', 'custom']")),
            parse_func=(Optional[Callable], Field(default=None, exclude=True, description="the function to parse the LLM output. It receives the LLM output and returns a dict.")),
            __base__=Action, 
            execute=customize_action_execute
        )

        customize_action = customize_action_cls(
            name = generate_dynamic_class_name(name+" Action"),
            description=desc, 
            prompt=prompt, 
            inputs_format=action_input_type, 
            outputs_format=action_output_type,
            parse_mode=parse_mode,
            parse_func=parse_func
        )
        return customize_action
    
    def _check_output_parser(self, outputs: List[dict], output_parser: Type[ActionOutput]):
        """
        Check if the output parser is valid.
        """
        if output_parser is not None:
            if not isinstance(output_parser, type):
                raise TypeError(f"output_parser must be a class, but got {type(output_parser).__name__}")
            if not issubclass(output_parser, ActionOutput):
                raise ValueError(f"`output_parser` must be a class and a subclass of `ActionOutput`, but got `{output_parser.__name__}`.")
        
        # check if the output parser is compatible with the outputs
        output_parser_fields = output_parser.get_attrs()
        for field in outputs:
            if field["name"] not in output_parser_fields:
                raise ValueError(
                    f"The output parser `{output_parser.__name__}` is not compatible with the `outputs`.\n"
                    f"The output parser fields: {output_parser_fields}.\n"
                    f"The outputs: {outputs}."
                )
    
    def _store_inputs_outputs_info(self, inputs: List[dict], outputs: List[dict]):
        """
        Store the inputs and outputs information for the customize action.
        """
        self._action_input_types, self._action_input_required = {}, {} 
        for field in inputs:
            required = field.get("required", True)
            self._action_input_types[field["name"]] = field["type"]
            self._action_input_required[field["name"]] = required
        self._action_output_types, self._action_output_required = {}, {}
        for field in outputs:
            required = field.get("required", True)
            self._action_output_types[field["name"]] = field["type"]
            self._action_output_required[field["name"]] = required
    
    def save_module(self, path: str, ignore: List[str] = [], **kwargs)-> str:
        """
        Save the customize agent to a JSON file.
        """
        customize_action = self.get_action(self.customize_action_name)
        action_input_params = customize_action.inputs_format.get_attrs()
        action_output_params = customize_action.outputs_format.get_attrs()
        
        config = {
            "class_name": "CustomizeAgent",
            "name": self.name,
            "description": self.description,
            "prompt": customize_action.prompt,
            "llm_config": self.llm_config.to_dict(exclude_none=True),
            "inputs": [
                {
                    "name": field,
                    "type": self._action_input_types[field],
                    "description": field_info.description,
                    "required": self._action_input_required[field]
                }
                for field, field_info in customize_action.inputs_format.model_fields.items() if field in action_input_params
            ],
            "outputs": [
                {
                    "name": field,
                    "type": self._action_output_types[field],
                    "description": field_info.description,
                    "required": self._action_output_required[field]
                }
                for field, field_info in customize_action.outputs_format.model_fields.items() if field in action_output_params
            ]
        }

        for ignore_key in ignore:
            config.pop(ignore_key, None)
        
        # Save to JSON file
        with open(path, 'w', encoding='utf-8') as f:
            json.dump(config, f, indent=4, ensure_ascii=False)

        return path
    